#### 医院挂号系统

##### 一、医院设置接口模块

- 不同的医院连接到本系统时，需要提供医院自己的信息，如名称、编号、api基础路径和签名密钥等，这些信息也称为**医院设置**

###### 1、整合Swagger2

- 新建Swagger的config配置类
- 因为Swagger在common模块下，与Service不同，因此需要在引用的同时在主启动类上使用注解`@ComponentScan(basePackages = {"com.edu"})`来确保可以扫描到swagger的配置类
- 在Controller上使用`@Api`注解，来添加对该类的中文描述。在方法上使用注解`@ApiOperation`，来添加对该方法的中文描述

###### 2、功能开发

- 都是基本的MP常规操作，没意思
- 查询医院设置表中的所有信息、逻辑删除医院的设置信息、分页、条件查询医院设置、新增医院设置、根据id查询对应的医院设置、修改医院设置的信息、批量删除医院设置、修改医院的可用状态、向管理系统发送密钥

###### 3、自定义异常类

- 新建实体类继承RuntimeException，该类作为自定义异常实体类可以自己抛出（感觉没卵用，但是要知道怎么自定义异常类）

###### 4、自定义全局异常处理器

- 在类上使用`@ControllerAdvice`注解，进行组件的注册
- 本质是AOP，提供了多种指定Advice的规则拦截，默认什么也不写，则拦截所有的Controller，因此每个Controller发生异常时，该处理器都会进行检测并拦截，从而达到自定义处理异常的功能

###### 5、统一日志处理

- 新建xml配置文件，可以将指定的日志级别输出到指定的文件夹中（没配置，需要的话再看，8难）



##### 二、数据字典模块

- 即通用基础数据，如省市区层级联动数据、学历、民族等

###### 1、显示基础数据的层级关系

- 根据传入的id查询其子节点
- 在实体类中新增字段hasChild，但并不存在于数据库表中，用于向前端返回值时，前端判断是否有子节点而现实展开、折叠的图标。前端并才用懒加载模式，只有当点开时，才会发送请求去查询该节点下的子节点。

###### 2、导入导出数据

- 使用第三方技术EasyExcel操作Excel

- 引入依赖

    ```xml
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>easyexcel</artifactId>
        <version>2.1.1</version>
    </dependency>
    ```

- 写操作（将数据写入到Excel中）

    - 创建实体类，并在字段上添加`@ExcelProperty("表头名称")`注解，将Excel中的表头信息与实体类字段一一对应起来

    ```java
    //设置生成的Excel文件存放的位置
    String fileName = "F:\\Excel\\foo.xlsx";
    //传入文件路径及对应的实体类，并设置sheet信息，最后将List写入
    EasyExcel.write(fileName, UserData.class).sheet("我是sheet信息").doWrite(list.of(1, 2, 3));
    ```

- 读操作（将Excel中的数据读取出来）

    - 在对应的实体类的对应字段上添加`@ExcelProperty(value = "表头名称", index = 0)`注解，表示该字段在Excel中是第几列

    - 创建一个监听器用来读取Excel，新建一个类继承`AnalysisEventListener<对应的实体类>`

        - 默认实现两个方法：其中`Invoke`表示一行一行的读取Excel中的内容，且从第二行开始（第一行是标头）。
        - `doAfterAllAnalysed`表示全部读取完之后要执行的操作
        - 非默认实现的方法：`invokeHeadMap`用来返回表头的索引和表头的kv值，如：`{0=表头,1=表头啊}`

        ```java
        //读取Excel的文件路径
        String fileName = "F:\\Excel\\bar.xlsx";
        //传入文件路径及对应的实体类，并将监听器(foobar类继承了AnalysisEventListener)放入，sheet不设置时默认读取第一个sheet
        EasyExcel.read(fileName, UserData.class, new foobar()).sheet().doRead();
        //该方法执行时，会调用监听器中的Invoke方法
        ```

- 导出Excel

    - 导出时是下载操作，因此要使用`HttpServletResponse`设置下载信息
    - 导出的实体跟查询出来的实体不相同，因此采用对象的拷贝，又因为拷贝的是集合，`beanutils.copyproperties`不支持拷贝集合，如果遍历拷贝效率较低，因此采用AlibabaFastJson将List集合转成Json，再将Json转为对应的List集合List`<DictEeVo> dictEeVos = JSON.parseArray(JSON.toJSONString(list), DictEeVo.class);`

- Excel导入数据

    - 使用`MultipartFile`获取用户上传的文件
    - 监听器中是一行一行读的，因此可以使用`beanutils.copyproperties`进行对象的拷贝，并插入到数据库中

###### 3、添加缓存

- 数据字典经常查询，且不经常改变，因此适合放入缓存中。
- 配置RedisConfig，自定义key生成规则、自定义Redis序列化器和TTL时间，并使用注解`@EnableCaching`开启缓存功能
- 在实现类的查询方法上添加注解`@Cacheable(value = "dict", keyGenerator = "keyGenerator")`，表明该方法的返回值写到redis中，在更新数据的方法上添加`@CacheEvict(value = "dict", allEntries = true)`，表示有数据更新时就从缓存中移除。其中value表示操作的缓存key是哪一个（实际中key=value+keyGenerator ），而`@Cacheable`和`@CacheEvict`中的value一致时，可以表示同名的可缓存操作，一个添加缓存，一个删除缓存。因此value只是idea层面的唯一标识。

###### 4、使用Nginx做请求转发

- hosp服务在8201端口，cmn在8202端口，使用Nginx做统一的端口转发
- 先试用简单的Win版完成功能，后面会换成SpringCloudGateway做服务网关



##### 三、对接接口（作为接口提供者）

- 向外暴露接口，供医院平台调用

###### 1、上传医院信息接口

- 在医院平台中，将Json格式的数据上传并解析成Map类型，进行医院信息的传输
- 使用`HttpServletRequest`获取从医院传过来的信息
- 得到的信息是Map类型，转成Json格式后，再转换成对应的实体类进行保存

###### 2、签名密钥校验

- 在调用对接的接口之前，根据医院上传的信息得到MD5加密后的签名和医院的编码，并根据编码查询数据库中的签名，并同样进行MD5加密，进行对比，相同则可以调用接口，不同则抛异常
- 在医院上传的数据中，有logodata字段，保存的是图片经过BASE64编码的，但在编码过程中可能存在字符丢失的情况（如+变成空字符），需要单独处理

###### 3、查询医院接口

- 根据医院编号查询对应的医院信息，在调用接口前，依旧需要对签名进行比对，无难度

###### 4、上传科室接口

- 同样的获取医院上传过来的信息并保存，且需要签名认证，无难度

###### 5、查询、删除科室接口

- 医院会上传页码和条数，因此查询科室接口需要分页查询
- 根据医院上传的参数，进行科室的条件删除

###### 6、上传排班接口

- 同样根据上传过来的数据进行保存

###### 7、查询、删除排班接口

- 同样分页查询排班
- 根据医院上传的医院编号和排班编号删除指定排班





##### 八、用户登录模块-OAuth2

- OAuth2用来解决开放系统间的授权问题、单点登录问题

###### 1、微信扫码登录

- 在配置文件中写入微信接口的id、secret值、回调地址（自己的域名）、前端地址
- 在工具类中，新建一个类，在Bean加载时将配置类中的值加载到该类中

###### 2、生成微信扫描二维码

- 网站内嵌二维码微信登录时，要先引入微信提供的JS文件
- 在需要使用微信登录的地方实例给定的JS对象，自定义的接口就是返回所需要的数据
- 完成Js对象的实例化之后，在前端点击时，即可显示登录二维码

###### 3、编写回调的方法，获取扫描人的信息

- 扫描完二维码在点击确认时，微信后台会自动调用回调地址，回调地址就是自定义的接口地址
- 该回调地址在微信后台进行配置
- 在调用回调方法时，微信会传入两个参数，code和state
    - 拿着获取的code临时票据的值去请求微信提供的地址，会返回access_token（访问凭证）和openid（微信唯一标识）
    - 拿着access_toke和openid再去请求微信提供的地址，会返回扫描人的信息
    - 绑定手机号，把手机号和微信扫描人信息添加到数据库中
- 在后端进行请求时，添加依赖并使用httpclient，用来模拟网页发出请求
- 登录成功后，使用JWT生成token并放到请求头中
- 回调方法的最后，手动重定向到要跳转的页面



##### 九、个人认证模块-阿里云OSS

- 用户认证需要上传证件图片、首页轮播图也需要上传图片，因此要做文件服务，而且阿里云OSS是一个很好的分布式文件服务系统

###### 1、使用oss控制台

- 创建Bucket，作为存储的容器
- 创建完成后，可以尝试上传文件，自动生成的url命名规则为：bucket名称+地域节点域名+文件名

###### 2、文件服务实现

- 搭建service-oss模块
- 引入oss依赖
- 将访问路径加入到网关中
- 新建utlis类，在bean加载时，将配置文件中的oss配置数据加载进来

###### 3、用户认证

- 只有用户认证了之后，才能进行就诊，而认证就是更新用户的信息
- 因为使用了jwt，因此编写工具类，从请求头中获取jwt的token来获取当前登录用户人的信息
- 接口：根据前端传递过来的参数，封装为用户信息并进行认证
    - 先根据id查询出用户，然后设置用户的认证信息，最后更新用户信息
- 接口：根据用户的id查询用户信息

###### 4、就诊人管理

- 预约下单需要选择就诊人，就诊人管理就是实现一个完整的增删改查，其中需要用到cmn模块的内容，因此需要远程调用
- 接口：根据当前登录用户的id查询其所有的就诊人列表
    - 光查出Patient实体中的数据还不够，需要去数据字典中进一步的查询，并将得到的数据进行封装返回
    - 因为Patient中某些Type字段只是单纯的数字，而真正需要显示的信息要在数据字典中去查
- 接口：将当前用户添加为就诊人
- 接口：根据就诊人id获取就诊人的信息
    - 同样的，单查询的信息不完整，需要用到远程调用来完成信息的完善
- 接口：修改就诊人的信息
    - MP的updateById标准更新功能
- 接口：删除就诊人
    - MP的removeById标准删除接口

###### 5、平台用户管理

- 统一管理用户登录、用户认证与就诊人
- 接口：条件分页查询用户列表
    - 没啥难度，拼凑查询条件，查询出来后，要把编码对应的变成名称
- 接口：用户锁定，用来修改用户的状态（锁定、解锁）
- 接口：点击用户查看用户的详情信息
    - 先根据userId查询出对应的用户信息，并将编号修改为对应的名称
    - 然后再根据userId查询出与之相关联的就诊人的信息
    - 将所有的信息封装的Map中并返回
- 接口：用户认证审批列表，同按条件分页查询用户列表，只是把所有的用户显示出来而已，因此已经实现过了（前端默认只显示认证中的用户）
- 接口：审批修改用户状态
    - 先根据UserId查询出对应的用户，修改用户状态为审核通过，然后更新即可



##### 十、预约挂号模块

###### 1、预约挂号详情显示

- 点击某一个科室后，获取可预约的排班信息，即显示该科室从今天开始到未来10天的挂号信息（如某一天是否有号、无号）
- 接口：根据预约的时间、医院编码、科室编码，展示可预约的日期数据，并分页显示
    - 需要将医院提供的预约时间拼接上日期
    - 根据医院设置的放号周期来计算所有可预约的时间
    - 手动分页
    - 麻烦的地方是自己根据得到的预约规则手动封装可预约的日期并手动分页
    - 然后根据可预约的日期来获取剩余预约数
    - 使用map集合进行数据合并，key为日期，value为预约规则和剩余数量等信息
- 再点击某一天的挂号信息时，获取排班数据，即显示挂号的详情信息（如上午的号源、挂号价格、剩余挂号量、医师等）
- 接口：选择日期并展示当天可预约的列表

###### 2、预约确认

- 点击某一天的排班获取排班信息，在有剩余号源的前提下，进行预约并选择就诊人下单
- 接口：点击某一排班信息时，查询排班数据，并通过封装返回额外的信息



##### 十一、挂号订单模块-RabbitMQ

###### 1、预约下单

- 点击确认挂号，进行下单。确认挂号时，生成一条订单信息，其中包含就诊人信息、挂号排班信息
    - 获取就诊人信息
        - 接口：在service-user模块中添加实现的接口（其中接口路径前缀为inner，表示内部调用），并新建service-user-client模块，进行远程调用
            - 已经有现成的实现方法（根据就诊人id获取其信息），直接使用即可
    - 获取排班下单信息与规则信息
        - 接口：在service-hosp模块中添加实现的接口（其中接口路径前缀为inner，表示内部调用），并新建service-hosp-client模块，进行远程调用
            - 接口：根据排班id获取预约下单数据（包含排班信息和预约规则信息）
            - 接口：根据医院编码获取医院签名信息实现方法
    - 获取医院签名信息，然后通过接口去医院预约下单（下单时需要用到医院平台的下单接口）
        - 接口：医院管理端已经完成了下单操作，用户端只需要调用即可（发送http请求的工具类建议看一下）
    - **封装RabbitMQ**：预约成功后我们要更新预约数和短信提醒预约成功，为了提高下单的并发性，这部分逻辑我们就交给mq为我们完成，预约成功发送消息即可
        - 创建mq公有模块
        - 在mq模块中封装service方法进行消息的发送、配置MQ消息转换器、添加常量（交换机、队列、路由key名称）
        - 在service-msm模块中（该模块中是用来发送短信），引入mq公有模块，并新建一个receiver监听器，当监听到队列中有信息时，就进行指定方法的调用。（消费者端）
        - 在service-hosp模块中（用来更新排班数量），引入mq公有模块，并新建监听器，当队列中有消息时，调用更新排班数据的方法。（消费者端）
    - 下单成功后更新排班信息并发送短信（生产者端）
        - 下单 -> 预约下单mq监听器接收，更新排班信息 -> 再通过mq发送短信 -> 短信mq监听器接收，做发短信操作
